컬렉션 프레임워크 (Collection Framework)
	1. 데이터를 다루기 위한 표준화된 구조
	2. 핵심 구조
		Collection - List 		- ArrayList
						  		- LinkedList
						  		- Vector
					
				   - Set 		- HashSet
		
		Map	  	   - HashMap
				   - SortedMap  - TreeMap
				   - Hashtable  
				   
	3. 주요 인터페이스의 핵심 기능
		1) List
			- 순서가 있는 데이터의 집합
			- 중복 저장 허용
		2) Set
			- 순서가 없는 데이터의 집합
			- 중복 저장 불가
		3) Map
			- 키와 값의 쌍으로 이루어진 데이터
			- 순서가 없는 데이터의 집합
			- 키는 중복 저장 불가
			- 값(value)는 중복 저장 허용
			
	4. 반복자(Iterator)를 사용할 수 있다.
		List<String> list = new ArrayList<>();
		Iterator itr = list.iterator(); // itr : 컬렉션의 요소를 꺼낼 수 있다.
		

ArrayList
	1. 객체(인스턴스)를 여러 개 저장할 수 있는 "배열"을 구현한 컬렉션이다
	2. 가장 많이 사용된다
	3. 기존에는 Vector를 많이 사용했다
	4. 장점
		- 구조가 단순하다
		- 읽어들이는 속도가 빠르다
		- 저장된 객체들의 변화가 적은 경우에 사용하면 좋다.
	5. 단점
		- 일단 만들고 나면 나중에 크기 변경이 힘들다.
		- 처음부터 크게 만들면 공간 낭비가 생긴다.
		- 비순차적 접근이 느리다
		- 데이터의 중간 위치에 추가/제거가 어렵다.
		
LinkedList
	1. 자신과 연결된 다음 요소에 대한 참조 + 데이터로 구성된다.
	2. 비연속적인 공간을 사용한다
	3. 장점
		- 추가 / 삭제 작업이 빠르다.
		- 잦은 추가 / 삭제가 발생되는 경우에 사용한다.
	4. 단점
		- 순차적인 순회가 느리다.
		- 구현이 어렵고, 오류가 발생할 가능성이 있다.
		
HashSet
	1. Set 인터페이스를 구현한 대표적인 클래스이다.
	2. 중복된 데이터는 저장되지 않는다.
	3. 중복된 데이터 판단 원리
		(1) hashCode() 확인
			- 값이 다르면 equals() 호출해서 동등 비교
			- 값이 다르면 다른 데이터로 판단
		(2) equals() 확인
			- 
	4. 사용자가 정의한 객체(인스턴스)를 저장하려면 hashCode(), equals() 오버라이드 해야함.
	5. 저장 순서가 없다.
	6. 순서를 유지하려면 LinkedHashSet 클래스를 사용한다.
	
HashMap
	1. 해시코드를 사용하는 Map 이다.
	2. 키(key) + 값(value)의 조합으로 데이터를 저장한다. 
	3. 중복된 데이터 판단 원리
		(1) hashCode() 확인
			- 값이 다르면 equals() 호출해서 동등 비교
			- 값이 다르면 다른 데이터로 판단
		(2) equals() 확인
			- 
	4. 사용자가 정의한 객체(인스턴스)를 저장하려면 hashCode(), equals() 오버라이드 해야함.
	5. 저장 순서가 없다.